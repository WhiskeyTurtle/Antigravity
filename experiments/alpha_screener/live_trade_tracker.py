import json
import os
import time
from typing import Dict, List

BASE_DIR = os.path.dirname(os.path.abspath(__file__))
LIVE_STATE_FILE = os.path.join(BASE_DIR, "live_trade_state.json")
DUST_SOL_THRESHOLD = 0.001
EPSILON = 1e-9


class LiveTradeTracker:
    def __init__(self):
        self.state_file = LIVE_STATE_FILE
        self.open_positions: Dict[str, dict] = {}
        self.closed_positions: List[dict] = []
        self.total_pnl_sol = 0.0
        self.load_state()

    @staticmethod
    def _to_float(v, default=0.0) -> float:
        try:
            return float(v)
        except Exception:
            return float(default)

    def _calculate_pnl_totals(self):
        """
        Return (verified_pnl_sol, external_estimate_pnl_sol).
        Verified includes only trades with on-chain tx signatures generated by this system.
        External estimate includes reconciliation-only synthetic closes.
        """
        verified = 0.0
        external = 0.0
        for t in self.closed_positions:
            pnl = self._to_float(t.get("pnl_sol", 0.0), 0.0)
            if bool(t.get("external_sync", False)):
                external += pnl
            else:
                verified += pnl
        return verified, external

    def load_state(self):
        if not os.path.exists(LIVE_STATE_FILE):
            return
        try:
            with open(LIVE_STATE_FILE, "r", encoding="utf-8") as f:
                data = json.load(f)
            self.open_positions = data.get("open_positions", {})
            for _, pos in self.open_positions.items():
                if "avg_entry_fdv" not in pos:
                    pos["avg_entry_fdv"] = 0.0
                if "basis_token_amount" not in pos:
                    pos["basis_token_amount"] = float(pos.get("token_amount", 0.0) or 0.0)
                pos.setdefault("strategy_mode", "")
                pos.setdefault("strategy_meta", {})
                pos.setdefault("live_tp1_hit", False)
                pos.setdefault("live_tp2_hit", False)
                pos.setdefault("live_peak_price", float(pos.get("avg_entry_price_sol", 0.0) or 0.0))
                pos.setdefault("live_runner_peak_price", float(pos.get("avg_entry_price_sol", 0.0) or 0.0))
                pos.setdefault("live_red_streak", 0)
                pos.setdefault("last_mark_price", float(pos.get("avg_entry_price_sol", 0.0) or 0.0))
                pos.setdefault("last_mark_fdv", float(pos.get("avg_entry_fdv", 0.0) or 0.0))
                pos.setdefault("last_mark_at", 0.0)
            self.closed_positions = data.get("closed_positions", [])
            for t in self.closed_positions:
                t.setdefault("strategy_mode", "")
            verified, _external = self._calculate_pnl_totals()
            self.total_pnl_sol = verified
        except Exception:
            self.open_positions = {}
            self.closed_positions = []
            self.total_pnl_sol = 0.0

    def save_state(self):
        verified, external = self._calculate_pnl_totals()
        state = {
            "open_positions": self.open_positions,
            "closed_positions": self.closed_positions,
            "total_pnl_sol": verified,
            "total_pnl_sol_external_estimate": external,
        }
        with open(LIVE_STATE_FILE, "w", encoding="utf-8") as f:
            json.dump(state, f, indent=2)

    def record_buy(
        self,
        token: str,
        token_amount: float,
        sol_spent: float,
        tx_sig: str = "",
        entry_fdv: float = 0.0,
        strategy_mode: str = "",
        strategy_meta: dict = None,
    ):
        if token_amount <= 0 or sol_spent <= 0:
            return

        pos = self.open_positions.get(token)
        now = time.time()
        strategy_mode = str(strategy_mode or "")
        strategy_meta = dict(strategy_meta or {})
        entry_fdv_f = float(entry_fdv or 0.0)
        if not pos:
            self.open_positions[token] = {
                "token": token,
                "token_amount": token_amount,
                "basis_token_amount": token_amount,
                "sol_spent": sol_spent,
                "avg_entry_price_sol": sol_spent / token_amount,
                "avg_entry_fdv": entry_fdv_f,
                "opened_at": now,
                "last_buy_tx": tx_sig,
                "strategy_mode": strategy_mode,
                "strategy_meta": strategy_meta,
                "live_tp1_hit": False,
                "live_tp2_hit": False,
                "live_peak_price": sol_spent / token_amount,
                "live_runner_peak_price": sol_spent / token_amount,
                "live_red_streak": 0,
                "last_mark_price": sol_spent / token_amount,
                "last_mark_fdv": entry_fdv_f,
                "last_mark_at": now,
            }
        else:
            old_token_amt = float(pos.get("token_amount", 0.0))
            old_basis_amt = float(pos.get("basis_token_amount", old_token_amt) or old_token_amt)
            new_token_amt = float(pos.get("token_amount", 0.0)) + token_amount
            new_basis_amt = old_basis_amt + token_amount
            new_sol_spent = float(pos.get("sol_spent", 0.0)) + sol_spent
            pos["token_amount"] = new_token_amt
            pos["basis_token_amount"] = new_basis_amt
            pos["sol_spent"] = new_sol_spent
            pos["avg_entry_price_sol"] = (new_sol_spent / new_basis_amt) if new_basis_amt > 0 else 0.0
            new_entry_fdv = entry_fdv_f
            old_avg_fdv = float(pos.get("avg_entry_fdv", 0.0) or 0.0)
            if new_entry_fdv > 0 and new_basis_amt > 0:
                pos["avg_entry_fdv"] = ((old_avg_fdv * old_basis_amt) + (new_entry_fdv * token_amount)) / new_basis_amt
            pos["last_buy_tx"] = tx_sig
            if strategy_mode:
                pos["strategy_mode"] = strategy_mode
            if strategy_meta:
                meta = pos.setdefault("strategy_meta", {})
                meta.update(strategy_meta)
            pos["last_mark_price"] = float(pos.get("avg_entry_price_sol", 0.0) or 0.0)
            pos["last_mark_fdv"] = float(pos.get("avg_entry_fdv", 0.0) or 0.0)
            pos["last_mark_at"] = now
            pos.setdefault("live_tp1_hit", False)
            pos.setdefault("live_tp2_hit", False)
            pos.setdefault("live_peak_price", float(pos.get("avg_entry_price_sol", 0.0) or 0.0))
            pos.setdefault("live_runner_peak_price", float(pos.get("avg_entry_price_sol", 0.0) or 0.0))
            pos.setdefault("live_red_streak", 0)

        self.save_state()

    def import_external_position(
        self,
        token: str,
        token_amount: float,
        mark_price_sol: float = 0.0,
        entry_fdv: float = 0.0,
    ):
        """
        Import a wallet-held token that is not currently tracked as an open position.
        Cost basis is approximated from current mark price to keep PNL neutral at import.
        """
        tok = str(token or "").strip()
        amt = float(token_amount or 0.0)
        px = float(mark_price_sol or 0.0)
        if not tok or amt <= 0:
            return None

        if tok in self.open_positions:
            return None

        now = time.time()
        sol_spent = amt * px if px > 0 else 0.0
        self.open_positions[tok] = {
            "token": tok,
            "token_amount": amt,
            "basis_token_amount": amt,
            "sol_spent": sol_spent,
            "avg_entry_price_sol": px if px > 0 else 0.0,
            "avg_entry_fdv": float(entry_fdv or 0.0),
            "opened_at": now,
            "last_buy_tx": "",
            "strategy_mode": "",
            "strategy_meta": {},
            "live_tp1_hit": False,
            "live_tp2_hit": False,
            "live_peak_price": px if px > 0 else 0.0,
            "live_runner_peak_price": px if px > 0 else 0.0,
            "live_red_streak": 0,
            "last_mark_price": px if px > 0 else 0.0,
            "last_mark_fdv": float(entry_fdv or 0.0),
            "last_mark_at": now,
            "external_imported": True,
        }
        self.save_state()
        return {"action": "imported", "token": tok, "token_amount": amt}

    def record_sell(self, token: str, token_amount_sold: float, sol_received: float, reason: str = "", tx_sig: str = ""):
        if token_amount_sold <= 0 or sol_received <= 0:
            return None

        pos = self.open_positions.get(token)
        if not pos:
            return None

        open_token_amt = float(pos.get("token_amount", 0.0) or 0.0)
        open_basis_amt = float(pos.get("basis_token_amount", open_token_amt) or open_token_amt)
        open_sol_spent = float(pos.get("sol_spent", 0.0) or 0.0)
        if open_token_amt <= 0 or open_basis_amt <= 0:
            return None

        sold_total = max(0.0, float(token_amount_sold or 0.0))
        sold_basis_amt = min(sold_total, open_basis_amt)
        sold_basis_ratio = min(1.0, sold_basis_amt / open_basis_amt) if open_basis_amt > 0 else 0.0
        cost_basis_sol = open_sol_spent * sold_basis_ratio
        attributed_sol_received = float(sol_received or 0.0)
        if sold_total > EPSILON and sold_basis_amt >= 0:
            attributed_sol_received = attributed_sol_received * (sold_basis_amt / sold_total)
        pnl_sol = attributed_sol_received - cost_basis_sol
        pnl_pct = (pnl_sol / cost_basis_sol * 100.0) if cost_basis_sol > 0 else 0.0
        close_time = time.time()
        opened_at = float(pos.get("opened_at", 0.0) or 0.0)
        duration = max(0.0, close_time - opened_at) if opened_at > 0 else 0.0

        closed = {
            "token": token,
            "token_amount_sold": sold_total,
            "basis_token_amount_sold": sold_basis_amt,
            "sol_received": attributed_sol_received,
            "sol_received_total": float(sol_received or 0.0),
            "cost_basis_sol": cost_basis_sol,
            "pnl_sol": pnl_sol,
            "pnl_pct": pnl_pct,
            "reason": reason,
            "tx_sig": tx_sig,
            "strategy_mode": str(pos.get("strategy_mode", "") or ""),
            "strategy_meta": dict(pos.get("strategy_meta", {}) or {}),
            "source_type": str((pos.get("strategy_meta", {}) or {}).get("source_type", "") or ""),
            "source_label": str((pos.get("strategy_meta", {}) or {}).get("source_label", "") or ""),
            "source_author": str((pos.get("strategy_meta", {}) or {}).get("source_author", "") or ""),
            "source_author_name": str((pos.get("strategy_meta", {}) or {}).get("source_author_name", "") or ""),
            "source_tweet_id": str((pos.get("strategy_meta", {}) or {}).get("source_tweet_id", "") or ""),
            "entry_time": opened_at,
            "opened_at": opened_at,
            "duration": duration,
            "closed_at": close_time,
        }
        self.closed_positions.append(closed)
        verified, _external = self._calculate_pnl_totals()
        self.total_pnl_sol = verified

        remaining_token = max(0.0, open_token_amt - sold_total)
        remaining_basis = max(0.0, open_basis_amt - sold_basis_amt)
        remaining_sol = max(0.0, open_sol_spent - cost_basis_sol)
        if remaining_token <= EPSILON or remaining_basis <= EPSILON or remaining_sol <= DUST_SOL_THRESHOLD:
            self.open_positions.pop(token, None)
        else:
            pos["token_amount"] = remaining_token
            pos["basis_token_amount"] = remaining_basis
            pos["sol_spent"] = remaining_sol
            pos["avg_entry_price_sol"] = (remaining_sol / remaining_basis) if remaining_basis > 0 else 0.0

        self.save_state()
        return closed

    def get_stats(self):
        verified, external = self._calculate_pnl_totals()
        self.total_pnl_sol = verified
        return {
            "total_pnl_sol": verified,
            "external_pnl_estimate_sol": external,
            "open_positions": len(self.open_positions),
            "closed_trades": len(self.closed_positions),
        }

    def get_open_positions(self):
        rows = list(self.open_positions.values())
        rows.sort(key=lambda x: float(x.get("opened_at", 0) or 0))
        return rows

    def get_history(self):
        return self.closed_positions

    def reset_state(self):
        before = {
            "open_positions": len(self.open_positions),
            "closed_trades": len(self.closed_positions),
            "total_pnl_sol": float(self.total_pnl_sol or 0.0),
        }
        self.open_positions = {}
        self.closed_positions = []
        self.total_pnl_sol = 0.0
        self.save_state()
        return before

    def update_position_runtime(self, token: str, updates: dict, persist: bool = True) -> bool:
        tok = str(token or "").strip()
        if not tok or tok not in self.open_positions:
            return False
        if not isinstance(updates, dict) or not updates:
            return False
        self.open_positions[tok].update(dict(updates))
        if persist:
            self.save_state()
        return True

    def get_strategy_summary(self) -> Dict[str, dict]:
        summary: Dict[str, dict] = {}
        for t in self.closed_positions:
            mode = str(t.get("strategy_mode", "") or "kol_momentum_scalper")
            pnl = self._to_float(t.get("pnl_sol", 0.0), 0.0)
            row = summary.setdefault(
                mode,
                {"trades": 0, "wins": 0, "losses": 0, "total_pnl_sol": 0.0},
            )
            row["trades"] += 1
            if pnl >= 0:
                row["wins"] += 1
            else:
                row["losses"] += 1
            row["total_pnl_sol"] += pnl

        for mode, row in summary.items():
            trades = max(1, int(row.get("trades", 0)))
            row["win_rate"] = (float(row.get("wins", 0)) / trades) * 100.0
            row["mode_label"] = mode
        return summary

    def reconcile_token_balance(
        self,
        token: str,
        onchain_token_amount: float,
        mark_price_sol: float = 0.0,
        reason: str = "EXTERNAL_WALLET_SYNC",
    ):
        """
        Reconcile tracked open position against actual on-chain token amount.
        If on-chain amount is lower than tracked, records a synthetic external sell.
        """
        pos = self.open_positions.get(token)
        if not pos:
            return {"action": "noop", "token": token, "details": "position_not_found"}

        tracked_amount = float(pos.get("token_amount", 0.0) or 0.0)
        tracked_basis_amount = float(pos.get("basis_token_amount", tracked_amount) or tracked_amount)
        tracked_sol_spent = float(pos.get("sol_spent", 0.0) or 0.0)
        onchain_amount = max(0.0, float(onchain_token_amount or 0.0))

        if tracked_amount <= EPSILON or tracked_basis_amount <= EPSILON or tracked_sol_spent <= DUST_SOL_THRESHOLD:
            self.open_positions.pop(token, None)
            self.save_state()
            return {"action": "removed_stale", "token": token}

        # If on-chain amount is higher, do not mutate bot cost basis.
        # We only align token amount for reconciliation visibility.
        if onchain_amount > tracked_amount + EPSILON:
            add_amount = onchain_amount - tracked_amount
            pos["token_amount"] = onchain_amount
            pos["avg_entry_price_sol"] = (tracked_sol_spent / tracked_basis_amount) if tracked_basis_amount > 0 else 0.0
            pos["external_untracked_amount"] = max(
                0.0,
                float(pos.get("external_untracked_amount", 0.0) or 0.0) + add_amount,
            )
            self.save_state()
            return {
                "action": "external_increase_detected",
                "token": token,
                "added_amount": add_amount,
                "tracked": tracked_amount,
                "onchain": onchain_amount,
            }

        # If on-chain amount is effectively equal, no change.
        if abs(onchain_amount - tracked_amount) <= EPSILON:
            return {"action": "noop", "token": token, "tracked": tracked_amount, "onchain": onchain_amount}

        sold_amount = max(0.0, tracked_amount - onchain_amount)
        sold_basis_amt = min(sold_amount, tracked_basis_amount)
        sold_ratio = min(1.0, sold_basis_amt / tracked_basis_amount) if tracked_basis_amount > 0 else 0.0
        cost_basis_sol = tracked_sol_spent * sold_ratio

        effective_price = float(mark_price_sol or 0.0)
        if effective_price > 0:
            sol_received = sold_basis_amt * effective_price
        else:
            # Fallback to cost basis when no reliable mark price is available.
            sol_received = cost_basis_sol

        pnl_sol = sol_received - cost_basis_sol
        pnl_pct = (pnl_sol / cost_basis_sol * 100.0) if cost_basis_sol > 0 else 0.0

        closed = {
            "token": token,
            "token_amount_sold": sold_amount,
            "basis_token_amount_sold": sold_basis_amt,
            "sol_received": sol_received,
            "cost_basis_sol": cost_basis_sol,
            "pnl_sol": pnl_sol,
            "pnl_pct": pnl_pct,
            "reason": reason,
            "tx_sig": "",
            "external_sync": True,
            "strategy_mode": str(pos.get("strategy_mode", "") or ""),
            "closed_at": time.time(),
        }
        self.closed_positions.append(closed)
        verified, _external = self._calculate_pnl_totals()
        self.total_pnl_sol = verified

        remaining_token = max(0.0, onchain_amount)
        remaining_basis = max(0.0, tracked_basis_amount - sold_basis_amt)
        remaining_sol = max(0.0, tracked_sol_spent - cost_basis_sol)

        if remaining_token <= EPSILON or remaining_basis <= EPSILON or remaining_sol <= DUST_SOL_THRESHOLD:
            self.open_positions.pop(token, None)
            action = "closed"
        else:
            pos["token_amount"] = remaining_token
            pos["basis_token_amount"] = remaining_basis
            pos["sol_spent"] = remaining_sol
            pos["avg_entry_price_sol"] = (remaining_sol / remaining_basis) if remaining_basis > 0 else 0.0
            action = "reduced"

        self.save_state()
        return {
            "action": action,
            "token": token,
            "sold_amount": sold_amount,
            "remaining_amount": remaining_token,
            "pnl_sol": pnl_sol,
            "reason": reason,
        }
